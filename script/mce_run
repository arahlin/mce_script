#!/bin/bash
#
# Acquires data from the MCE and create or append to a .run file.
#
# It also writes the current unix time into the run_id word of the
# clock card so that it appears in the frame header.
#
# This script is intended to be fairly low-level, it shouldn't do
# more than it needs to to collect a complete data file.

source $MAS_SCRIPT/mas_library.bash
SCRNAME=mce_run

function usage {
    echo "Usage:              $SCRNAME <filename> <numpts> <RC> [options]"
    echo
    echo "     filename   is the filename; \$MAS_DATA will be prepended."
    echo "     numpts     is the number of frames e.g. 24000"
    echo "     RC         is the card number e.g. \"3\", or \"s\" for all"
    echo
    echo "Recognized options (must follow the mandatory arguments):"
    echo "     --dirfile       force dirfile data format"
    echo "     --flatfile      force flatfile data format"
    echo "     --no-locking    do not check/assert the data driver lock"
    echo "     --sequence <n>  break output into chunks of size n frames"
    [ "$1" == "" ] || exit $1
    exit 1
}

# Defaults

acq_config_suffix=""

# Three mandatory arguments

[ $# -lt 3 ] && usage

filename=$MAS_DATA/$1
runfilename=${filename}.run
numpts=$2
rc=$3
shift 3

# Options processing
locking=1
fileseq=

while [ "$#" != "0" ]; do 
    case "$1" in
	"--flatfile")
	    acq_config_suffix=""
	    ;;
	
	"--dirfile")
	    acq_config_suffix="_dirfile"
	    ;;

	"--no-locking")
	    locking=0
	    ;;
	
	"--sequence")
	    fileseq=$2
	    shift
	    ;;
	*)
	    echo "$SCRNAME : unknown option '$a'"
	    usage
	    ;;
    esac
    shift
done

# Query the data lock state
if [ "$locking" == "1" ]; then
    if [ "$( command_reply lock_query )" == "1" ]; then
	echo "$SCRNAME : Data lock is asserted, aborting."
	exit 1
    fi
fi


# Write current ctime into run_id location of frame header.  This
# won't necessarily match the filename; but is better than nothing.
# Also, put array ID code and data mode in 'user_word' field.

mce_update_userword $rc

# Re-initialize the servo.  Can't hurt.
if [ "$rc" == "s" ]; then
    mce_cmd -qx wb rca flx_lp_init 1
else
    mce_cmd -qx wb rc$rc flx_lp_init 1
fi


#RUN FILE CREATION: NO MCE WRITES PAST THIS POINT

echo "RUNFILE_NAME=$runfilename"

# Don't remove runfile, it may have been pre-initialized
[ -e "$runfilename" ] || touch $runfilename

# This is my favourite part.
mce_status >> $runfilename
if [ "$?" != "0" ]; then
    echo "$SCRNAME : MCESTATUS action failed!"
    exit 1
fi

# Apply frameacq stamp

frameacq_stamp $rc ${filename} $numpts >> $runfilename
if [ "$?" != "0" ]; then
    echo "$SCRNAME : frameacq_stamp failed!"
    exit 1
fi

# Acquisition

echo "FRAME_BASENAME=$filename"

lock_opts=
[ "$locking" == "1" ] && lock_opts="-X lock_down"

[ "$fileseq" != "" ] && acq_config_suffix=${acq_config_suffix}_fs

mce_cmd -q -o / \
    $lock_opts \
    -X "acq_config${acq_config_suffix} $filename rc$rc $fileseq" \
    -X "acq_go $numpts"

if [ "$?" != "0" ]; then
    echo "$SCRNAME : mce_cmd returned error"
    exit 1
fi

exit 0
