#!/usr/bin/python
# -*- mode: python -*-

from mheadsup import clients, util, plotters, qtgfx, gfx, geometries

import sys, os, time
import subprocess
import numpy as np

from PyQt4 import QtCore, QtGui


defaults = util.get_defaults()
defaults.update({
    'client_name': 'qtg',
    })


class qtgPlotter(plotters.displayClient,QtGui.QWidget):
    def __init__(self, addr, name='qtg', img=None):
        plotters.displayClient.__init__(self, addr, name)
        QtGui.QWidget.__init__(self)
        
        self.mutex = QtCore.QMutex()
        self.img = []

        self.info = qtgfx.infoSummary()
        self.info.fromTextItemList(self.texts)

        if img != None:
            self.img.append((img, 'default'))
        
        self.init_gfx()

    def init_gfx(self):
        self.view = qtgfx.tightView()
        self.scene = QtGui.QGraphicsScene()
        self.view.setScene(self.scene)
        layout = QtGui.QGridLayout()
        self.setLayout(layout)
        layout.addWidget(self.view, 0,0)
        layout.addWidget(self.info, 1,0)
        self.streamList = qtgfx.simpleCombo()
        self.streamList.currentIndexChanged.connect(self.select_stream)
        self.geomList = qtgfx.simpleCombo()
        self.geomList.currentIndexChanged.connect(self.select_geom)
        #w = QtGui.QWidget()
        w = QtGui.QGridLayout()
        layout.addLayout(w, 2, 0)
        for i, (n,c) in enumerate(
            [('Stream', self.streamList),
             ('Geometry', self.geomList)]):
            w.addWidget(QtGui.QLabel(n), i, 0)
            w.addWidget(c, i, 1, 1, 2)

        for img in self.img:
            self.scene.addItem(img[0])
        self.view.fitInView(self.scene.itemsBoundingRect(),
                            QtCore.Qt.KeepAspectRatio)

    # Real Q signal handlers
    def select_stream(self, *args):
        idx = args[0]
        print ' -select_stream', idx
        if idx < 0:
            print 'deselected'
            self.data_handler = None
        else:
            stream_name = self.streamList.get_item(idx)
            self.subscribe_data(stream_name)
            print 'selected ', stream_name

    def select_geom(self, *args):
        idx = args[0]
        print ' -select_geometry', idx
        if idx < 0:
            print 'deselected'
        else:
            geom_data = self.geomList.get_item(idx)
            print 'selected ', geom_data['name']
            self.geom = geometries.pixelSetGeometry.decode(geom_data)
            #self.img[0][0].animateMove(self.geom.coords[0],
            #                           self.geom.coords[1])
            self.img[0][0].create_blips_from_geometry(self.geom)
            
            

    # Not Q signal handlers

    def stream_list_changed(self):
        new_stream_names = [s.name[:-5] for s in self.stream_list_handler.streams
                            if s.type == 'data']
        self.streamList.update_items(labels=new_stream_names)

    def geom_list_changed(self):
        geoms = [(s['name'], s) for s in self.data_handler.info.
                 get('geometries', [])]
        self.geomList.update_items(items=geoms)

    # Imagery

    def add_image(self, image, image_name=None):
        self.img.append((image, image_name))

    def update_image(self, data=None, idx=0):
        """
        Updates the image, or some aspect of it (scale, zoom, ...).
        """
        if idx >= len(self.img):
            return
        img, _ = self.img[idx]
        if data == None:
            data = self.last_data
        # Update zoom to match image?
        self.last_data = data
        # Update data mask?
        if self.controls.get('mask_update'):
            self.data_mask = np.array(self.controls['mask']).astype('bool')
            self.controls['mask_update'] = False
        mask = self.data_mask
        if mask == None or mask.shape != data.shape:
            mask = np.ones(data.shape, 'bool')
        if mask.sum() == 0:
            mask[0,0] = True
        # Update zrange?
        auto, black, white = self._get_scale(data[mask])
        # Update.
        mask_val = self.controls.get('mask_value', (black+white)/2)
        # Condition data...
        data = self._norm_data(data, black, white, mask, mask_val)
        img.set_data(data.transpose())

    def poll(self):
        self.info.set_text('time_now', '%.1f' % time.time())
        if self.controls.get('exit'):
            print 'Exiting on server request.'
            del self.timer
            self.close()
            app.exit()
        if not self.connected:
            self.connect()
            if not self.connected:
                print 'Exiting on failed reconnect.'
                app.exit()
        if self.controls.get('poll_controls'):
#            self.set_client_var('poll_controls', 1)
            self.controls['poll_controls'] = 0
        if not self.mutex.tryLock():
            return
        with qtgfx.mutexHolder(self.mutex):
            self.idle_count += 1
            ok, addr, data = self.do_receive()
            if not ok or addr == None:
                return

            if False and self.data_handler == None:
                # Try to connect to a stream?
                if self.stream_list_handler == None:
                    # We have nothing going on.
                    print 'no handler'
                    return
                dstreams = [x.name for x in self.stream_list_handler.streams
                            if x.type == 'data']
                if len(dstreams) > 0:
                    self.subscribe_data(dstreams[0][:-5])
                else:
                    print 'no dstreams'
                return
            if self.stream_list_handler != None:
                sh = self.stream_list_handler
                if sh.changes > 0:
                    self.stream_list_changed()
                    sh.changes = 0
            if self.data_handler == None:
                return

            if self.data_handler.info_update:
                print 'info_update', self.data_handler.info
                self.data_handler.info_update = False
                self.info.set_text('data_mode', 
                                   self.data_handler.info.get('data_mode', ''))
                self.geom_list_changed()
                print self.data_handler.info.keys()

            n_frames = len(self.data_handler.frames)
            if n_frames > 0:
                self.info.set_text('time_frame', '%.1f' % time.time())
                data = self.data_handler.frames.pop(0)
                self.update_image(data)
                if self.idle_count == 0 and n_frames > 10:
                    # Falling behind... change update frequency?
                    print 'Falling behind...'
                    self.data_handler.frames = []
                self.idle_count = 0

        if 0:
            if op == 'ctrl':
                if 'mask' in item:
                    self.controls['mask_update'] = True
                if 'data_mode' in item:
                    self.info.set_text('data_mode', self.controls['data_mode'])

    def launch(self, rate=10., refresh_rate=20.):
        self.refresh_rate = refresh_rate
        self.frame_rate = refresh_rate
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.poll)
        self.timer.start(1./self.refresh_rate)
        self.frame_t0 = None
        self.idle_count = 0
        #pp.set_client_var('rate', rate)


if 0: #if not sys.flags.interactive:
    def sigint(signum, frame):
        app.exit()
    import signal 
    signal.signal(signal.SIGINT, sigint)


if __name__ == '__main__':
    o = util.upOptionParser()
    o.add_option('-i','--interactive',action='store_true')
    o.add_option('--no-controller',action='store_true')
    o.add_option('--data-rate', type=float, default=10.,
                 help="frame rate to request from server")
    o.add_option('--display-rate', type=float, default=100.,
                 help="rate at which to update the display")
    o.add_option('--profile',
                 help="load a plotting profile file")
    o.add_standard(defaults)
    opts, args = o.parse_args(defaults=defaults)

    if opts.interactive and not sys.flags.interactive:
        # Uh, ok.
        sys.exit(subprocess.call(['/usr/bin/python','-i'] + sys.argv))

    # Qt init
    app = QtGui.QApplication([])
    win = QtGui.QMainWindow()
    win.resize(400,600)
    win.move(100,100)

    #img = qtgfx.GridDisplay()
    img = qtgfx.BlipDisplay()

    #qp = qplotter(img)

    pp = qtgPlotter(opts.server, opts.name, img=img)
    time.sleep(.1)

    win.setCentralWidget(pp)
    win.show()

    pp.launch(rate=opts.data_rate, refresh_rate=opts.display_rate)

    if sys.flags.interactive == 1 and not opts.no_controller:
        disp = plotters.displayController(opts.server, opts.name+'_ctrl')
        if opts.profile != None:
            disp.restore(opts.profile)
        # Since we're so Qt
        #disp.watch_controls(enable=True)
        #disp.timer = QtCore.QTimer()
        #disp.timer.timeout.connect(disp.watch_controls)
        #disp.timer.start(200.)
    else:
        app.exec_()
